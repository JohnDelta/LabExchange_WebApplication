# Lab Exchange - Web Application

## Description

The project constists of the following services

- Web Application in react : localhost:8080

- Authentication Service : localhost:8081
  https://github.com/JohnDelta/Authentication-Service

- Classses Service : localhost:8082
  https://github.com/JohnDelta/Classes-Service

- Notification Service : localhost:8083
  https://github.com/JohnDelta/Notification-service

- Messenger Service : localhost:8084
  https://github.com/JohnDelta/Messenger-service

- MongoDB server : localhost:27017

- RabbitMQ server : localhost:56014

## Services Architecture

![Screenshot 2021-03-15 143305](https://user-images.githubusercontent.com/53333356/111154215-a46d8c80-859b-11eb-80e1-bd41a51cd7ec.png)

# Installation

To run this project, you must first follow each of the previous links and pull them (save them in folders named after the repo's name).
Then, run ` mvn clean install ` to make the .jar files in each one.

## Install and deploy all with docker compose

- Build compose ``` docker-compose -f docker-compose.yaml --project-name lab_exchange build ```
- Run compose ``` docker-compose -f docker-compose.yaml --project-name lab_exchange up ```
- Stop it ``` docker-compose -f docker-compose.yaml down ```

## Install web app only using npm

- install all necessary packages:
  - `npm install`
  - `npm install stompjs`
  - `npm install sockjs`
  - `npm install react-router-dom`
- run the webapp `npm run`

## Install web app using docker

- Run the react web app
  - build the web app ` npm run build `
  - build the image ``` docker build -t webapp . ```
  - find the image and its ID ``` docker image ls ```
  - create and run the container by image ID ``` docker run -it --rm -p 8080:8080 {ID} ```
  - see all docker containers and find ID ``` docker ps ```
  - stop / start containers ``` docker container stop {ID} ```

### Kubernetes notes

- Run in Kubernetes:
  - Add to your system32/etc/host ` 127.0.0.1 lab-exchange.com ` (works for Docker Desktop K8s)
  - First run ` mvn clean install ` to each of the projects
  - Then run compose build ` docker-compose -f docker-compose.yaml --project-name lab_exchange build `
  - And last apply the k8 config ` kubectl apply -f config-file.yaml `
  - Set-up Ingress (see bellow)

- Ingress: 
  - https://stackoverflow.com/a/65771251/14434647
  - https://kubernetes.github.io/ingress-nginx/deploy/
  - Mandadory resources for Ingress : ` kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml `
  - Bare-metal Ingress nginx using NodePort (kubectl) : `kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.46.0/deploy/static/provider/baremetal/deploy.yaml`

- Commands:
  - Execute the configuration file (create or update) `kubectl apply -f config-file.yaml`
  - Delete the configuration file `kubectl delete -f config-file.yaml`
  - Log to console `kubectl logs pod-name`
  - Get terminal `kubectl exec -it pod-name -- bin/bash`
  - Get info about pod `kubectl describe pod pod-name` (and '-o wide' for more information)
  - Validate that a service runs the correct pod `kubectl describe service service-name` (see the endpoints) 
  - Get pods, services `kubectl get pod, service` (or type 'all')
  - See the ingress controller running `kubectl get pod -n kube-system`

- Every configuration file needs:
  - Metadata
  - Specification (Attributes specific to the 'kind')
  - Status (Automaticaly generated by k8. If the current and desired state do not match it tries to fix it (self-healing feature).)

<b>K8 Config files</b>

- Service
  - Create internal services so pods can talk to each other
  - Create external service to run in the local environment
  - Basic configuration file structure

 ``` 
 
 # Internal
 apiVersion: v1
 kind: Service
 metadata:
  name: nameOfService
 spec:
  selector: # Make a connection between the service and the deployment
    app: nameOfApp # Label from the deploy config
  ports:
    - protocol: TCP
      port: 80 # service port
      targetPort: 8080 # pod port from the deploy config 
 
 # External
apiVersion: v1
 kind: Service
 metadata:
  name: nameOfService
 spec:
  selector: # Make a connection between the service and the deployment
    app: nameOfApp # Label from the deploy config
  type: LoadBalancer # accepts external requests
  ports:
    - protocol: TCP
      port: 8080  # service port
      targetPort: 8080 # pod port from the deploy config
      nodePort: 30000 # external oppened port 30000 - 32767 range

# Ingress (Needs ingress controller)
apiVersion:
kind: Ingress
metadata:
  name: ingressName
spec:
  rules:
    - host: myapp.com # valid domain address, map to server if hosted
      http:
        paths:
          - backend:
            serviceName: myapp-internal-service # same with the internal service name
            servicePort: 8080

 ```

 - Ingress Controller (needs installation)
  - You can install K8s Nginx Ingress Controller
  - Evaluate all rules in the ingress service config
  - Manage all redirections

- Deployment
 - Has the blueprint for creating pods
 - needs name and image to use
 - Basic Configuration file structure

 ```

apiVersion: apps/v1
kind: Deployment # Configuration file type
metadata:
  name: nameOfDeployment
  labels:
    app: nameOfApp
spec: # Specification for the pod
  replicas: 1 # How many replicas I want to create
  selector:
    matchLabels:
      app: nameOfApp
    template: # Blueprint for the pods
      metadata:
        labels:
          app: nameOfApp # Should match the selector.app name in the service configuration file
      spec: # Specification for the deployment
        containers:
        - name: nameOfApp
          image: nameOfImage
          ports:
          - containerPort: 8080 # Should match the targetPod in the service configuration
          env:
            -name: MONGO_INITDB_ROOT_USERNAME
            valueFrom: # Reference a secret key
              secretKeyRef:
                name: mongodb-secret
                key: username
            -name: MONGO_INITDB_ROOT_HOST
            valueFrom: # Reference a config map key
              configMapKeyRef:
                name: configMapName
                key: configMapKey

 ```

- ConfigMap: 
  - Contains enviromental variables
  - External configuration
  - Centralized
  - Other components can use it
  - Structure

  ``` 
  
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: nameOfConfigMap
  data:
    database_url: mongodb-service
  
  ```

- Secret: Contains usernames, passwords etc, so they aren't exposed
  - Structure

  ``` 
  
  apiVersion: v1
  kind: Secret
  metadata:
    name: mongodb-secret
  type: Opaque
  data:
    username: guest # (the values here MUST be base64 Encoded)
    password: guest
  
  ```

- Last, we need an External Service that will allow external services to talk to the pod (to run localy)

### notes

- Ensure that the app runs perfectly now using docker compose and its ready

 

- Start search on how to set up the k8 process

- I can not set up CICD on the first local environment


 - When everything works, I can later use the google run to deploy the 4 services
 - use mlab to deploy mongo
 - final problem is the rabbitmq ?
